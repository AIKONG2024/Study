from keras.models import Sequential
from keras.layers import Dense
import numpy as np

# 1.데이터
x = np.array([1,2,3,4,5,6])
y = np.array([1,2,3,5,4,6])

# 요 데이터를 훈련해서 최소의 loss를 만들기

# 2.모델구성
model = Sequential()
model.add(Dense(1, input_dim = 1))

# 3.컴파일,훈련
model.compile(loss='mse', optimizer='adam')
model.fit(x, y, epochs=7000)

# 평가,예측 (7)
loss = model.evaluate(x,y)

print("로스: ", loss) #많이 돌려도 핑퐁치는 구간이 발생할 수 있다.

result = model.predict([1,2,3,4,5,6,7])
print("예측: ", result)



#1000번
# 로스:  0.664930522441864
# 1/1 [==============================] - 0s 53ms/step
# 예측:  [[5.728688]]

#100번
# 로스:  79.67520904541016
# 1/1 [==============================] - 0s 61ms/step
# 예측:  [[-9.149137]]

#500번
# 로스:  50.21503829956055
# 1/1 [==============================] - 0s 49ms/step
# 예측:  [[-6.0597115]]

# 1300번
# 로스:  21.84705924987793
# 1/1 [==============================] - 0s 53ms/step
# 예측:  [[-2.0589933]]

# 5000번
# 로스:  0.3254908621311188
# 1/1 [==============================] - 0s 49ms/step
# 예측:  [[6.7357516]]

#10000번
# 로스:  0.32380977272987366
# 1/1 [==============================] - 0s 48ms/step
# 예측:  [[6.800944]]

#12000번
# 로스:  0.32380950450897217
# 1/1 [==============================] - 0s 54ms/step
# 예측:  [[6.7999988]]

# 15000번
# 1/1 [==============================] - 0s 39ms/step
# 예측:  [[6.7999997]]

#20000번
# 로스:  0.32380956411361694
# 1/1 [==============================] - 0s 58ms/step
# 예측:  [[6.7999997]]

# 50000번
# 로스:  0.3238093852996826
# 1/1 [==============================] - 0s 50ms/step
# 예측:  [[6.7997932]]

# 에포: